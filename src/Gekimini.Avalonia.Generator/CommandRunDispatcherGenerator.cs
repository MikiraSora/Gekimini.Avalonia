using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Gekimini.Avalonia.Generator;

[Generator]
public class CommandRunDispatcherGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodsWithAttr = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0,
                static (ctx, _) => GetMethodInfo(ctx))
            .Where(x => x is not null)!;

        context.RegisterSourceOutput(methodsWithAttr.Collect(), static (spc, methods) =>
        {
            if (methods.IsDefaultOrEmpty)
                return;

            var groups = methods
                .Where(m => m != null)
                .GroupBy(m => m!.ClassSymbol, SymbolEqualityComparer.Default);

            foreach (var group in groups)
            {
                var classSymbol = group.Key;
                if (classSymbol == null)
                    continue;

                var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
                    ? string.Empty
                    : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()}";

                var className = classSymbol.Name;
                var classAccess = classSymbol.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Internal => "internal",
                    Accessibility.Protected => "protected",
                    _ => "private"
                };

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                if (!string.IsNullOrEmpty(ns))
                {
                    sb.AppendLine(ns);
                    sb.AppendLine("{");
                }

                sb.AppendLine($"   partial class {className}");
                sb.AppendLine("    {");
                sb.AppendLine(
                    "        global::System.Threading.Tasks.Task global::Gekimini.Avalonia.Framework.Commands.ICommandHandler.Run(global::Gekimini.Avalonia.Framework.Commands.Command command)");
                sb.AppendLine("        {");
                sb.AppendLine("            switch (command.CommandDefinition)");
                sb.AppendLine("            {");

                foreach (var item in group)
                {
                    sb.AppendLine($"                case {item.CommandDefinitionName}:");
                    sb.AppendLine($"                    return {item.MethodName}(command);");
                }

                sb.AppendLine("            }");
                sb.AppendLine("            return global::System.Threading.Tasks.Task.CompletedTask;");
                sb.AppendLine("        }");
                sb.AppendLine("    }");

                if (!string.IsNullOrEmpty(ns))
                    sb.AppendLine("}");

                var hintName = $"{className}_CommandRunDispatcher.g.cs";
                spc.AddSource(hintName, sb.ToString());
            }
        });
    }

    private static MethodInfo? GetMethodInfo(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not MethodDeclarationSyntax method)
            return null;

        var model = ctx.SemanticModel;
        var methodSymbol = model.GetDeclaredSymbol(method) as IMethodSymbol;
        if (methodSymbol == null)
            return null;

        // 查找 attribute
        foreach (var attr in methodSymbol.GetAttributes())
        {
            if (attr.AttributeClass is not INamedTypeSymbol attrClass)
                continue;

            if (attrClass.Name != "GenerateCommandRunDispatcherAttribute`1" && attrClass.Name != "GenerateCommandRunDispatcherAttribute")
                continue;

            if (attrClass.TypeArguments.Length != 1)
                continue;

            var commandType = attrClass.TypeArguments[0];
            return new MethodInfo(
                methodSymbol.ContainingType,
                methodSymbol.Name,
                commandType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            );
        }

        return null;
    }

    private class MethodInfo(
        INamedTypeSymbol ClassSymbol,
        string MethodName,
        string CommandDefinitionName)
    {
        public INamedTypeSymbol ClassSymbol { get; } = ClassSymbol;
        public string MethodName { get; } = MethodName;
        public string CommandDefinitionName { get; } = CommandDefinitionName;
    }
}